/**
 * Documentation Manager for FORGE MCP Server
 * Manages project documentation structure and organization
 */

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');

class DocsManager {
  constructor(baseDir, options = {}) {
    this.baseDir = baseDir;
    this.logger = options.logger || console;

    // Standard documentation structure
    this.structure = {
      'docs': {
        'prd': 'Product Requirements Documents',
        'architecture': 'Architecture and Design Documents',
        'api': 'API Documentation',
        'testing': 'Test Plans and Scenarios',
        'deployment': 'Deployment and Operations',
        'security': 'Security Documentation',
        'user-guides': 'User Documentation',
        'retrospectives': 'Project Retrospectives'
      }
    };
  }

  /**
   * Initialize documentation structure for a project
   */
  async initializeDocsStructure() {
    const docsPath = path.join(this.baseDir, 'docs');

    try {
      // Create main docs folder
      if (!fs.existsSync(docsPath)) {
        fs.mkdirSync(docsPath, { recursive: true });
        this.logger.info('Created docs/ folder');
      }

      // Create subdirectories
      for (const [folder, description] of Object.entries(this.structure.docs)) {
        const folderPath = path.join(docsPath, folder);
        if (!fs.existsSync(folderPath)) {
          fs.mkdirSync(folderPath, { recursive: true });

          // Create README for each folder
          const readmePath = path.join(folderPath, 'README.md');
          if (!fs.existsSync(readmePath)) {
            const readmeContent = `# ${description}

This folder contains ${description.toLowerCase()} for the project.

## Files

*Documents will be added here as the project progresses.*

---
*Generated by FORGE MCP Server*
`;
            fs.writeFileSync(readmePath, readmeContent);
          }
        }
      }

      // Create main docs README if it doesn't exist
      const mainReadmePath = path.join(docsPath, 'README.md');
      if (!fs.existsSync(mainReadmePath)) {
        const mainReadme = this.generateMainReadme();
        fs.writeFileSync(mainReadmePath, mainReadme);
      }

      // Create docs index
      await this.updateDocsIndex();

      return {
        success: true,
        path: docsPath,
        structure: this.structure
      };
    } catch (error) {
      this.logger.error('Failed to initialize docs structure:', error);
      throw error;
    }
  }

  /**
   * Generate main README for docs folder
   */
  generateMainReadme() {
    return `# Project Documentation

Welcome to the project documentation. This folder contains all technical and user documentation for the project.

## Structure

${Object.entries(this.structure.docs).map(([folder, desc]) =>
  `- **/${folder}/** - ${desc}`
).join('\n')}

## Quick Links

### Development
- [Product Requirements](./prd/) - Feature specifications and requirements
- [Architecture](./architecture/) - System design and architecture decisions
- [API Documentation](./api/) - API references and integration guides

### Quality & Operations
- [Test Plans](./testing/) - Test strategies and scenarios
- [Security](./security/) - Security policies and guidelines
- [Deployment](./deployment/) - Deployment procedures and configurations

### Learning
- [User Guides](./user-guides/) - End-user documentation
- [Retrospectives](./retrospectives/) - Project learnings and improvements

## Documentation Standards

1. **File Naming**: Use kebab-case for file names (e.g., \`user-authentication-prd.md\`)
2. **Versioning**: Include version numbers in document titles
3. **Dating**: Add creation and update dates to documents
4. **Review**: Mark documents with review status

## Contributing

When adding new documentation:
1. Place it in the appropriate subfolder
2. Update the folder's README.md
3. Follow the project's documentation templates
4. Request review from relevant stakeholders

---
*Generated by FORGE MCP Server - ${new Date().toISOString()}*
`;
  }

  /**
   * Save a PRD document
   */
  async savePRD(featureName, content, metadata = {}) {
    const docsPath = path.join(this.baseDir, 'docs', 'prd');

    // Ensure PRD folder exists
    if (!fs.existsSync(docsPath)) {
      await this.initializeDocsStructure();
    }

    const fileName = this.sanitizeFileName(featureName) + '-prd.md';
    const filePath = path.join(docsPath, fileName);

    // Add metadata header to content
    const fullContent = this.addDocumentMetadata(content, {
      type: 'PRD',
      feature: featureName,
      ...metadata
    });

    fs.writeFileSync(filePath, fullContent);
    this.logger.info(`PRD saved to docs/prd/${fileName}`);

    // Update docs index
    await this.updateDocsIndex();

    return {
      path: filePath,
      relativePath: `docs/prd/${fileName}`
    };
  }

  /**
   * Save architecture document
   */
  async saveArchitectureDoc(title, content, metadata = {}) {
    const docsPath = path.join(this.baseDir, 'docs', 'architecture');

    if (!fs.existsSync(docsPath)) {
      await this.initializeDocsStructure();
    }

    const fileName = this.sanitizeFileName(title) + '.md';
    const filePath = path.join(docsPath, fileName);

    const fullContent = this.addDocumentMetadata(content, {
      type: 'Architecture',
      title,
      ...metadata
    });

    fs.writeFileSync(filePath, fullContent);
    this.logger.info(`Architecture doc saved to docs/architecture/${fileName}`);

    await this.updateDocsIndex();

    return {
      path: filePath,
      relativePath: `docs/architecture/${fileName}`
    };
  }

  /**
   * Save test scenarios document
   */
  async saveTestScenarios(featureName, content, metadata = {}) {
    const docsPath = path.join(this.baseDir, 'docs', 'testing');

    if (!fs.existsSync(docsPath)) {
      await this.initializeDocsStructure();
    }

    const fileName = this.sanitizeFileName(featureName) + '-test-scenarios.md';
    const filePath = path.join(docsPath, fileName);

    const fullContent = this.addDocumentMetadata(content, {
      type: 'Test Scenarios',
      feature: featureName,
      ...metadata
    });

    fs.writeFileSync(filePath, fullContent);
    this.logger.info(`Test scenarios saved to docs/testing/${fileName}`);

    await this.updateDocsIndex();

    return {
      path: filePath,
      relativePath: `docs/testing/${fileName}`
    };
  }

  /**
   * Add metadata header to document
   */
  addDocumentMetadata(content, metadata) {
    const header = `---
title: ${metadata.title || metadata.feature || 'Untitled'}
type: ${metadata.type || 'Documentation'}
created: ${metadata.created || new Date().toISOString()}
updated: ${new Date().toISOString()}
version: ${metadata.version || '1.0.0'}
status: ${metadata.status || 'Draft'}
author: ${metadata.author || 'FORGE MCP Server'}
${metadata.cycleId ? `cycleId: ${metadata.cycleId}` : ''}
${metadata.tags ? `tags: [${metadata.tags.join(', ')}]` : ''}
---

`;
    return header + content;
  }

  /**
   * Update documentation index
   */
  async updateDocsIndex() {
    const docsPath = path.join(this.baseDir, 'docs');
    const indexPath = path.join(docsPath, '.forge-docs-index.yaml');

    const index = {
      updated: new Date().toISOString(),
      structure: {},
      documents: []
    };

    // Scan all doc folders
    for (const folder of Object.keys(this.structure.docs)) {
      const folderPath = path.join(docsPath, folder);
      if (fs.existsSync(folderPath)) {
        const files = fs.readdirSync(folderPath)
          .filter(f => f.endsWith('.md') && f !== 'README.md');

        index.structure[folder] = files.length;

        files.forEach(file => {
          index.documents.push({
            type: folder,
            file: file,
            path: `${folder}/${file}`,
            modified: fs.statSync(path.join(folderPath, file)).mtime
          });
        });
      }
    }

    fs.writeFileSync(indexPath, yaml.dump(index));
    return index;
  }

  /**
   * Get documentation statistics
   */
  async getDocsStats() {
    const indexPath = path.join(this.baseDir, 'docs', '.forge-docs-index.yaml');

    if (fs.existsSync(indexPath)) {
      const index = yaml.load(fs.readFileSync(indexPath, 'utf8'));
      return {
        totalDocuments: index.documents.length,
        byType: index.structure,
        lastUpdated: index.updated,
        recentDocuments: index.documents
          .sort((a, b) => new Date(b.modified) - new Date(a.modified))
          .slice(0, 5)
      };
    }

    return {
      totalDocuments: 0,
      byType: {},
      lastUpdated: null,
      recentDocuments: []
    };
  }

  /**
   * Sanitize file name
   */
  sanitizeFileName(name) {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9-]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
  }

  /**
   * Generate documentation from cycle
   */
  async generateCycleDocumentation(cycle, type = 'prd') {
    const templates = {
      prd: this.generatePRDFromCycle,
      architecture: this.generateArchitectureFromCycle,
      testing: this.generateTestPlanFromCycle
    };

    const generator = templates[type];
    if (!generator) {
      throw new Error(`Unknown documentation type: ${type}`);
    }

    const content = generator.call(this, cycle);

    // Save based on type
    switch (type) {
      case 'prd':
        return await this.savePRD(cycle.feature, content, { cycleId: cycle.id });
      case 'architecture':
        return await this.saveArchitectureDoc(cycle.feature, content, { cycleId: cycle.id });
      case 'testing':
        return await this.saveTestScenarios(cycle.feature, content, { cycleId: cycle.id });
      default:
        throw new Error(`Unsupported type: ${type}`);
    }
  }

  /**
   * Generate PRD from cycle data
   */
  generatePRDFromCycle(cycle) {
    return `# Product Requirements Document: ${cycle.feature}

## Executive Summary

**Feature**: ${cycle.feature}
**Priority**: ${cycle.priority}
**Status**: ${cycle.phase} Phase

## Description

${cycle.description || 'To be detailed...'}

## Requirements

### Functional Requirements

${cycle.tasks.Focus ? cycle.tasks.Focus
  .filter(t => !t.includes('test') && !t.includes('risk'))
  .map(t => `- ${t.replace(' âœ“', '')}`)
  .join('\n') : '- To be defined'}

### Non-Functional Requirements

- Performance: To be specified
- Security: ${cycle.tasks.Focus?.find(t => t.includes('risk')) ? 'Risks identified' : 'To be assessed'}
- Usability: To be defined

## Implementation Plan

### Phase Progress
- Focus: ${cycle.progress.Focus}% complete
- Orchestrate: ${cycle.progress.Orchestrate}% complete
- Refine: ${cycle.progress.Refine}% complete
- Generate: ${cycle.progress.Generate}% complete
- Evaluate: ${cycle.progress.Evaluate}% complete

### Tasks
${Object.entries(cycle.tasks)
  .map(([phase, tasks]) => `
#### ${phase} Phase
${tasks.map(t => `- ${t}`).join('\n')}`)
  .join('\n')}

## Success Metrics

To be defined during Evaluate phase.

## Notes

${cycle.notes || 'No additional notes.'}

---
*Generated from FORGE cycle: ${cycle.id}*
`;
  }

  /**
   * Generate architecture document from cycle
   */
  generateArchitectureFromCycle(cycle) {
    return `# Architecture Document: ${cycle.feature}

## Overview

This document describes the architecture for ${cycle.feature}.

## System Design

${cycle.tasks.Focus?.find(t => t.includes('architecture')) ?
  'Architecture design completed in Focus phase.' :
  'Architecture to be designed.'}

## Components

To be detailed during Orchestrate phase.

## Integration Points

To be identified during Refine phase.

## Security Considerations

${cycle.tasks.Focus?.find(t => t.includes('risk')) ?
  'Security risks identified and documented.' :
  'Security assessment pending.'}

---
*Generated from FORGE cycle: ${cycle.id}*
`;
  }

  /**
   * Generate test plan from cycle
   */
  generateTestPlanFromCycle(cycle) {
    return `# Test Plan: ${cycle.feature}

## Test Strategy

${cycle.tasks.Focus?.find(t => t.includes('test scenario')) ?
  'Test scenarios defined in Focus phase.' :
  'Test scenarios to be defined.'}

## Test Cases

To be detailed during Orchestrate and Refine phases.

## Test Execution

Planned for Generate phase.

## Acceptance Criteria

To be validated in Evaluate phase.

---
*Generated from FORGE cycle: ${cycle.id}*
`;
  }
}

module.exports = { DocsManager };