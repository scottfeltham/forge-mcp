/**
 * Documentation Manager for FORGE MCP Server
 * Manages project documentation structure and organization
 */

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');

class DocsManager {
  constructor(baseDir, options = {}) {
    this.baseDir = baseDir;
    this.logger = options.logger || console;

    // Standard documentation structure
    this.structure = {
      'docs': {
        'prd': 'Product Requirements Documents',
        'architecture': 'Architecture and Design Documents',
        'api': 'API Documentation',
        'testing': 'Test Plans and Scenarios',
        'deployment': 'Deployment and Operations',
        'security': 'Security Documentation',
        'user-guides': 'User Documentation',
        'retrospectives': 'Project Retrospectives'
      }
    };
  }

  /**
   * Initialize documentation structure for a project
   */
  async initializeDocsStructure() {
    const docsPath = path.join(this.baseDir, 'docs');

    try {
      // Create main docs folder
      if (!fs.existsSync(docsPath)) {
        fs.mkdirSync(docsPath, { recursive: true });
        this.logger.info('Created docs/ folder');
      }

      // Create subdirectories
      for (const [folder, description] of Object.entries(this.structure.docs)) {
        const folderPath = path.join(docsPath, folder);
        if (!fs.existsSync(folderPath)) {
          fs.mkdirSync(folderPath, { recursive: true });

          // Create README for each folder
          const readmePath = path.join(folderPath, 'README.md');
          if (!fs.existsSync(readmePath)) {
            const readmeContent = `# ${description}

This folder contains ${description.toLowerCase()} for the project.

## Files

*Documents will be added here as the project progresses.*

---
*Generated by FORGE MCP Server*
`;
            fs.writeFileSync(readmePath, readmeContent);
          }
        }
      }

      // Create main docs README if it doesn't exist
      const mainReadmePath = path.join(docsPath, 'README.md');
      if (!fs.existsSync(mainReadmePath)) {
        const mainReadme = this.generateMainReadme();
        fs.writeFileSync(mainReadmePath, mainReadme);
      }

      // Create docs index
      await this.updateDocsIndex();

      return {
        success: true,
        path: docsPath,
        structure: this.structure
      };
    } catch (error) {
      this.logger.error('Failed to initialize docs structure:', error);
      throw error;
    }
  }

  /**
   * Generate main README for docs folder
   */
  generateMainReadme() {
    return `# Project Documentation

Welcome to the project documentation. This folder contains all technical and user documentation for the project.

## Structure

${Object.entries(this.structure.docs).map(([folder, desc]) =>
    `- **/${folder}/** - ${desc}`
  ).join('\n')}

## Quick Links

### Development
- [Product Requirements](./prd/) - Feature specifications and requirements
- [Architecture](./architecture/) - System design and architecture decisions
- [API Documentation](./api/) - API references and integration guides

### Quality & Operations
- [Test Plans](./testing/) - Test strategies and scenarios
- [Security](./security/) - Security policies and guidelines
- [Deployment](./deployment/) - Deployment procedures and configurations

### Learning
- [User Guides](./user-guides/) - End-user documentation
- [Retrospectives](./retrospectives/) - Project learnings and improvements

## Documentation Standards

1. **File Naming**: Use kebab-case for file names (e.g., \`user-authentication-prd.md\`)
2. **Versioning**: Include version numbers in document titles
3. **Dating**: Add creation and update dates to documents
4. **Review**: Mark documents with review status

## Contributing

When adding new documentation:
1. Place it in the appropriate subfolder
2. Update the folder's README.md
3. Follow the project's documentation templates
4. Request review from relevant stakeholders

---
*Generated by FORGE MCP Server - ${new Date().toISOString()}*
`;
  }

  /**
   * Save a PRD document
   */
  async savePRD(featureName, content, metadata = {}) {
    const docsPath = path.join(this.baseDir, 'docs', 'prd');

    // Ensure PRD folder exists
    if (!fs.existsSync(docsPath)) {
      await this.initializeDocsStructure();
    }

    const fileName = this.sanitizeFileName(featureName) + '-prd.md';
    const filePath = path.join(docsPath, fileName);

    // Add metadata header to content
    const fullContent = this.addDocumentMetadata(content, {
      type: 'PRD',
      feature: featureName,
      ...metadata
    });

    fs.writeFileSync(filePath, fullContent);
    this.logger.info(`PRD saved to docs/prd/${fileName}`);

    // Update docs index
    await this.updateDocsIndex();

    return {
      path: filePath,
      relativePath: `docs/prd/${fileName}`
    };
  }

  /**
   * Save architecture document
   */
  async saveArchitectureDoc(title, content, metadata = {}) {
    const docsPath = path.join(this.baseDir, 'docs', 'architecture');

    if (!fs.existsSync(docsPath)) {
      await this.initializeDocsStructure();
    }

    const fileName = this.sanitizeFileName(title) + '.md';
    const filePath = path.join(docsPath, fileName);

    const fullContent = this.addDocumentMetadata(content, {
      type: 'Architecture',
      title,
      ...metadata
    });

    fs.writeFileSync(filePath, fullContent);
    this.logger.info(`Architecture doc saved to docs/architecture/${fileName}`);

    await this.updateDocsIndex();

    return {
      path: filePath,
      relativePath: `docs/architecture/${fileName}`
    };
  }

  /**
   * Save test scenarios document
   */
  async saveTestScenarios(featureName, content, metadata = {}) {
    const docsPath = path.join(this.baseDir, 'docs', 'testing');

    if (!fs.existsSync(docsPath)) {
      await this.initializeDocsStructure();
    }

    const fileName = this.sanitizeFileName(featureName) + '-test-scenarios.md';
    const filePath = path.join(docsPath, fileName);

    const fullContent = this.addDocumentMetadata(content, {
      type: 'Test Scenarios',
      feature: featureName,
      ...metadata
    });

    fs.writeFileSync(filePath, fullContent);
    this.logger.info(`Test scenarios saved to docs/testing/${fileName}`);

    await this.updateDocsIndex();

    return {
      path: filePath,
      relativePath: `docs/testing/${fileName}`
    };
  }

  /**
   * Add metadata header to document
   */
  addDocumentMetadata(content, metadata) {
    const header = `---
title: ${metadata.title || metadata.feature || 'Untitled'}
type: ${metadata.type || 'Documentation'}
created: ${metadata.created || new Date().toISOString()}
updated: ${new Date().toISOString()}
version: ${metadata.version || '1.0.0'}
status: ${metadata.status || 'Draft'}
author: ${metadata.author || 'FORGE MCP Server'}
${metadata.cycleId ? `cycleId: ${metadata.cycleId}` : ''}
${metadata.tags ? `tags: [${metadata.tags.join(', ')}]` : ''}
---

`;
    return header + content;
  }

  /**
   * Update documentation index
   */
  async updateDocsIndex() {
    const docsPath = path.join(this.baseDir, 'docs');
    const indexPath = path.join(docsPath, '.forge-docs-index.yaml');

    const index = {
      updated: new Date().toISOString(),
      structure: {},
      documents: []
    };

    // Scan all doc folders
    for (const folder of Object.keys(this.structure.docs)) {
      const folderPath = path.join(docsPath, folder);
      if (fs.existsSync(folderPath)) {
        const files = fs.readdirSync(folderPath)
          .filter(f => f.endsWith('.md') && f !== 'README.md');

        index.structure[folder] = files.length;

        files.forEach(file => {
          index.documents.push({
            type: folder,
            file: file,
            path: `${folder}/${file}`,
            modified: fs.statSync(path.join(folderPath, file)).mtime
          });
        });
      }
    }

    fs.writeFileSync(indexPath, yaml.dump(index));
    return index;
  }

  /**
   * Get documentation statistics
   */
  async getDocsStats() {
    const indexPath = path.join(this.baseDir, 'docs', '.forge-docs-index.yaml');

    if (fs.existsSync(indexPath)) {
      const index = yaml.load(fs.readFileSync(indexPath, 'utf8'));
      return {
        totalDocuments: index.documents.length,
        byType: index.structure,
        lastUpdated: index.updated,
        recentDocuments: index.documents
          .sort((a, b) => new Date(b.modified) - new Date(a.modified))
          .slice(0, 5)
      };
    }

    return {
      totalDocuments: 0,
      byType: {},
      lastUpdated: null,
      recentDocuments: []
    };
  }

  /**
   * Sanitize file name
   */
  sanitizeFileName(name) {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9-]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
  }

  /**
   * Generate documentation from cycle
   */
  async generateCycleDocumentation(cycle, type = 'prd') {
    const templates = {
      prd: this.generatePRDFromCycle,
      architecture: this.generateArchitectureFromCycle,
      testing: this.generateTestPlanFromCycle
    };

    const generator = templates[type];
    if (!generator) {
      throw new Error(`Unknown documentation type: ${type}`);
    }

    const content = generator.call(this, cycle);

    // Save based on type
    switch (type) {
    case 'prd':
      return await this.savePRD(cycle.feature, content, { cycleId: cycle.id });
    case 'architecture':
      return await this.saveArchitectureDoc(cycle.feature, content, { cycleId: cycle.id });
    case 'testing':
      return await this.saveTestScenarios(cycle.feature, content, { cycleId: cycle.id });
    default:
      throw new Error(`Unsupported type: ${type}`);
    }
  }

  /**
   * Generate PRD from cycle data using the standard FORGE template
   */
  generatePRDFromCycle(cycle) {
    return `# Product Requirements Document: ${cycle.feature}

## Executive Summary

**Problem Statement**: ${this.extractProblemStatement(cycle)}

**Solution Overview**: ${cycle.description || 'High-level solution to be detailed during Focus phase.'}

**Business Value**: Expected impact and benefits to be defined during requirements gathering.

## Target Users

### Primary Users
- **Primary User Type**: To be identified during Focus phase
- **Use Cases**: To be detailed during requirements gathering

### Secondary Users
- **Secondary User Type**: To be identified as needed

## Requirements

### Functional Requirements

#### Core Features
${this.generateFunctionalRequirements(cycle)}

#### Optional Features
- To be identified during Orchestrate phase

### Non-Functional Requirements

#### Performance
- Response time requirements: To be specified
- Throughput requirements: To be specified
- Scalability needs: To be assessed

#### Security
${this.generateSecurityRequirements(cycle)}

#### Usability
- User experience requirements: To be defined
- Accessibility requirements: To be specified
- Browser/device compatibility: To be determined

#### Reliability
- Uptime requirements: To be specified
- Error handling requirements: To be designed
- Data consistency needs: To be assessed

## User Stories

### Epic 1: ${cycle.feature}
- **US1.1**: As a user, I want [goal] so that [benefit]
  - **Acceptance Criteria**:
    - [ ] Given [context], when [action], then [outcome]
    - [ ] To be detailed during Focus phase

## Technical Considerations

### Architecture
${this.generateArchitectureSection(cycle)}

### Dependencies
- External systems and APIs: To be identified
- Third-party services: To be assessed
- Internal system dependencies: To be mapped

### Constraints
- Technical limitations: To be assessed
- Regulatory requirements: To be identified
- Business constraints: To be documented

### Risks and Mitigation
${this.generateRisksSection(cycle)}

## Success Metrics

### Primary KPIs
- **Success Metric 1**: To be defined during Focus phase
- **Success Metric 2**: To be defined during Focus phase

### Secondary KPIs
- **Additional Metrics**: To be identified as needed

### User Satisfaction
- User feedback mechanisms: To be designed
- Satisfaction targets: To be set
- Usage analytics: To be implemented

## Implementation Phases

### Phase 1: Foundation (Focus & Orchestrate)
- Requirements validation
- Technical design
- Architecture planning
- **Deliverables**: Architecture docs, detailed task breakdown
- **Progress**: Focus ${cycle.progress.Focus}%, Orchestrate ${cycle.progress.Orchestrate}%

### Phase 2: Core Development (Refine)
- Core feature implementation
- Unit and integration testing
- Code reviews
- **Deliverables**: Working core features with tests
- **Progress**: ${cycle.progress.Refine}%

### Phase 3: Polish & Deploy (Generate)
- Performance optimization
- Security hardening
- Documentation
- Production deployment
- **Deliverables**: Production-ready feature
- **Progress**: ${cycle.progress.Generate}%

### Phase 4: Validation (Evaluate)
- User acceptance testing
- Performance monitoring
- Success metrics validation
- **Deliverables**: Go-live decision, retrospective
- **Progress**: ${cycle.progress.Evaluate}%

## Current Development Status

**Phase**: ${cycle.phase}
**Started**: ${new Date(cycle.created).toLocaleDateString()}
**Priority**: ${cycle.priority}

### Active Tasks (${cycle.phase} Phase)
${this.formatActiveTasks(cycle)}

## Appendices

### Mockups and Wireframes
- Design assets: To be created during Focus/Orchestrate phases
- User flow diagrams: To be documented

### API Specifications
- Endpoint definitions: To be designed during Orchestrate phase
- Request/response schemas: To be documented
- Authentication details: To be specified

### Data Models
- Database schema changes: To be planned
- Data migration requirements: To be assessed

---

**Document Status**: ${cycle.phase === 'Focus' ? 'Draft' : cycle.phase === 'Evaluate' ? 'Approved' : 'In Progress'}
**Last Updated**: ${new Date().toISOString().split('T')[0]}
**FORGE Cycle**: ${cycle.id}
**FORGE Integration**: This PRD is designed for FORGE development cycle integration
`;
  }

  /**
   * Helper methods for PRD generation
   */
  extractProblemStatement(cycle) {
    return cycle.description ?
      `This feature addresses: ${cycle.description}` :
      'Problem statement to be defined during Focus phase.';
  }

  generateFunctionalRequirements(cycle) {
    const focusTasks = cycle.tasks.Focus || [];
    const requirements = focusTasks
      .filter(t => !t.includes('test') && !t.includes('risk') && !t.includes('architecture'))
      .map(t => `- **Requirement**: ${t.replace(' âœ“', '')}\n  - Acceptance Criteria: To be detailed\n  - Priority: ${cycle.priority}`);

    return requirements.length > 0 ? requirements.join('\n\n') : '- **Core Requirement**: To be defined during Focus phase\n  - Acceptance Criteria: Specific, testable criteria\n  - Priority: High/Medium/Low';
  }

  generateSecurityRequirements(cycle) {
    const hasSecurityTask = cycle.tasks.Focus?.find(t => t.includes('risk'));
    return hasSecurityTask ?
      '- Security risks: Identified during Focus phase\n- Authentication requirements: To be specified\n- Authorization requirements: To be defined\n- Data protection needs: To be assessed' :
      '- Authentication requirements: To be specified\n- Authorization requirements: To be defined\n- Data protection needs: To be assessed';
  }

  generateArchitectureSection(cycle) {
    const hasArchTask = cycle.tasks.Focus?.find(t => t.includes('architecture'));
    return hasArchTask ?
      '- High-level system design: Completed during Focus phase\n- Key components and interactions: Documented\n- Data flow and storage: Planned' :
      '- High-level system design: To be completed during Focus phase\n- Key components and interactions: To be documented\n- Data flow and storage: To be planned';
  }

  generateRisksSection(cycle) {
    const hasRiskTask = cycle.tasks.Focus?.find(t => t.includes('risk'));
    return hasRiskTask ?
      '- **Security Risks**: Identified and documented during Focus phase\n- **Technical Risks**: To be assessed during Orchestrate phase\n- **Business Risks**: To be evaluated' :
      '- **Risk 1**: To be identified during Focus phase\n- **Risk 2**: To be assessed and documented';
  }

  formatActiveTasks(cycle) {
    const phaseTasks = cycle.tasks[cycle.phase] || [];
    return phaseTasks.length > 0 ?
      phaseTasks.map(t => `- ${t}`).join('\n') :
      '*Tasks to be defined*';
  }

  /**
   * Generate architecture document from cycle
   */
  generateArchitectureFromCycle(cycle) {
    return `# Architecture Document: ${cycle.feature}

## Overview

This document describes the architecture for ${cycle.feature}.

## System Design

${cycle.tasks.Focus?.find(t => t.includes('architecture')) ?
    'Architecture design completed in Focus phase.' :
    'Architecture to be designed.'}

## Components

To be detailed during Orchestrate phase.

## Integration Points

To be identified during Refine phase.

## Security Considerations

${cycle.tasks.Focus?.find(t => t.includes('risk')) ?
    'Security risks identified and documented.' :
    'Security assessment pending.'}

---
*Generated from FORGE cycle: ${cycle.id}*
`;
  }

  /**
   * Generate test plan from cycle
   */
  generateTestPlanFromCycle(cycle) {
    return `# Test Plan: ${cycle.feature}

## Test Strategy

${cycle.tasks.Focus?.find(t => t.includes('test scenario')) ?
    'Test scenarios defined in Focus phase.' :
    'Test scenarios to be defined.'}

## Test Cases

To be detailed during Orchestrate and Refine phases.

## Test Execution

Planned for Generate phase.

## Acceptance Criteria

To be validated in Evaluate phase.

---
*Generated from FORGE cycle: ${cycle.id}*
`;
  }
}

module.exports = { DocsManager };